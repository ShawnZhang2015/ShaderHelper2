{
  "ver": "1.0.22",
  "uuid": "f7521e26-4ac8-4e0d-b798-e016b3c97763",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\n\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\n\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n\n  v_color = a_color;\n\n  gl_Position = pos;\n}\n",
        "frag": "\nprecision highp float;\n\n#if USE_ALPHA_TEST\n  \n  uniform float alphaThreshold;\n#endif\n\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\n\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\n\nvarying vec4 v_color;\n\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n#endif\n\nuniform sampler2D targetTex;\nuniform float time;\nconst float MIN_AMOUNT = -0.16;\nconst float MAX_AMOUNT = 1.3;\n\nconst float PI = 3.141592653589793;\n\nconst float scale = 512.0;\nconst float sharpness = 3.0;\n\nconst float cylinderRadius = 1.0 / PI / 2.0;\n\nvec3 hitPoint(float hitAngle, float yc, vec3 point, mat3 rrotation) {\n    float hitPoint = hitAngle / (2.0 * PI);\n    point.y = hitPoint;\n    return rrotation * point;\n}\n\nvec4 antiAlias(vec4 color1, vec4 color2, float distance) {\n    distance *= scale;\n    if (distance < 0.0) return color2;\n    if (distance > 2.0) return color1;\n    float dd = pow(1.0 - distance / 2.0, sharpness);\n    return ((color2 - color1) * dd) + color1;\n}\n\nfloat distanceToEdge(vec3 point) {\n    float dx = abs(point.x > 0.5 ? 1.0 - point.x : point.x);\n    float dy = abs(point.y > 0.5 ? 1.0 - point.y : point.y);\n    if (point.x < 0.0) dx = -point.x;\n    if (point.x > 1.0) dx = point.x - 1.0;\n    if (point.y < 0.0) dy = -point.y;\n    if (point.y > 1.0) dy = point.y - 1.0;\n    if ((point.x < 0.0 || point.x > 1.0) && (point.y < 0.0 || point.y > 1.0)) return sqrt(dx * dx + dy * dy);\n    return min(dx, dy);\n}\n\nvec4 seeThrough(float cylinderAngle, float yc, vec2 p, mat3 rotation, mat3 rrotation) {\n    float hitAngle = PI - (acos(yc / cylinderRadius) - cylinderAngle);\n    vec3 point = hitPoint(hitAngle, yc, rotation * vec3(p, 1.0), rrotation);\n\n    if (yc <= 0.0 && (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0)) {\n        return texture2D(targetTex, v_uv0);\n    }\n\n    if (yc > 0.0) return texture2D(texture, p);\n\n    vec4 color = texture2D(texture, point.xy);\n    vec4 tcolor = vec4(0.0);\n\n    return antiAlias(color, tcolor, distanceToEdge(point));\n}\n\nvec4 seeThroughWithShadow(float amount, float cylinderAngle, float yc, vec2 p, vec3 point, mat3 rotation, mat3 rrotation) {\n    float shadow = distanceToEdge(point) * 30.0;\n    shadow = (1.0 - shadow) / 3.0;\n    if (shadow < 0.0) shadow = 0.0;\n    else shadow *= amount;\n\n    vec4 shadowColor = seeThrough(cylinderAngle, yc, p, rotation, rrotation);\n    shadowColor.r -= shadow;\n    shadowColor.g -= shadow;\n    shadowColor.b -= shadow;\n    return shadowColor;\n}\n\nvec4 backside(float yc, vec3 point) {\n    vec4 color = texture2D(texture, point.xy);\n    float gray = (color.r + color.b + color.g) / 15.0;\n    gray += (8.0 / 10.0) * (pow(1.0 - abs(yc / cylinderRadius), 2.0 / 10.0) / 2.0 + (5.0 / 10.0));\n    color.rgb = vec3(gray);\n    return color;\n}\n\nvec4 behindSurface(float amount, float cylinderAngle, float yc, vec3 point, mat3 rrotation) {\n    float shado = (1.0 - ((-cylinderRadius - yc) / amount * 7.0)) / 6.0;\n    shado *= 1.0 - abs(point.x - 0.5);\n\n    yc = (-cylinderRadius - cylinderRadius - yc);\n\n    float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\n    point = hitPoint(hitAngle, yc, point, rrotation);\n\n    if (yc < 0.0 && point.x >= 0.0 && point.y >= 0.0 && point.x <= 1.0 && point.y <= 1.0 && (hitAngle < PI || amount > 0.5)){\n        shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / (71.0 / 100.0));\n        shado *= pow(-yc / cylinderRadius, 3.0);\n        shado *= 0.5;\n    } else\n        shado = 0.0;\n\n    return vec4(texture2D(targetTex, v_uv0).rgb - shado, 0.0);\n}\n\nvoid main(void) {\n    const float angle = 30.0 * PI / 180.0;\n    float c = cos(-angle);\n    float s = sin(-angle);\n\n    mat3 rotation = mat3(\n        c, s, 0,\n        -s, c, 0,\n        0.12, 0.258, 1\n    );\n\n    c = cos(angle);\n    s = sin(angle);\n\n    mat3 rrotation = mat3(\n        c, s, 0,\n        -s, c, 0,\n        0.15, -0.5, 1\n    );\n\n    vec3 point = rotation * vec3(v_uv0, 1.0);\n\n    float amount = time * (MAX_AMOUNT - MIN_AMOUNT) + MIN_AMOUNT;\n    float cylinderAngle = 2.0 * PI * amount;\n\n    float yc = point.y - amount;\n\n    if (yc < -cylinderRadius) {\n\n        gl_FragColor = behindSurface(amount, cylinderAngle, yc, point, rrotation);\n        return;\n    }\n\n    if (yc > cylinderRadius) {\n\n        gl_FragColor = texture2D(texture, v_uv0);\n        return;\n    }\n\n    float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\n\n    float hitAngleMod = mod(hitAngle, 2.0 * PI);\n    if ((hitAngleMod > PI && amount < 0.5) || (hitAngleMod > PI/2.0 && amount < 0.0)) {\n        gl_FragColor = seeThrough(cylinderAngle, yc, v_uv0, rotation, rrotation);\n        return;\n    }\n\n    point = hitPoint(hitAngle, yc, point, rrotation);\n\n    if (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0) {\n        gl_FragColor = seeThroughWithShadow(amount, cylinderAngle, yc, v_uv0, point, rotation, rrotation);\n        return;\n    }\n\n    vec4 color = backside(yc, point);\n\n    vec4 otherColor;\n    if (yc < 0.0) {\n        float shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / 0.71);\n        shado *= pow(-yc / cylinderRadius, 3.0);\n        shado *= 0.5;\n        otherColor = vec4(0.0, 0.0, 0.0, shado);\n    } else {\n        otherColor = texture2D(texture, v_uv0);\n    }\n\n    color = antiAlias(color, otherColor, cylinderRadius - abs(yc));\n\n    vec4 cl = seeThroughWithShadow(amount, cylinderAngle, yc, v_uv0, point, rotation, rrotation);\n    float dist = distanceToEdge(point);\n\n    gl_FragColor = antiAlias(color, cl, dist);\n}\n"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n\n  vec4 cc_screenSize;\n\n  vec4 cc_screenScale;\n\n  vec4 cc_nativeSize;\n\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n\n  vec4 cc_exposure;\n\n  vec4 cc_mainLitDir;\n\n  vec4 cc_mainLitColor;\n\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\n\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n\n  v_color = a_color;\n\n  gl_Position = pos;\n}\n",
        "frag": "\nprecision highp float;\n\n#if USE_ALPHA_TEST\n  \n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  }\n#endif\n\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\n\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\n\nin vec4 v_color;\n\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\n#endif\n\nuniform sampler2D targetTex;\nuniform properties {\n  float time;\n\n}\n\nconst float MIN_AMOUNT = -0.16;\nconst float MAX_AMOUNT = 1.3;\n\nconst float PI = 3.141592653589793;\n\nconst float scale = 512.0;\nconst float sharpness = 3.0;\n\nconst float cylinderRadius = 1.0 / PI / 2.0;\n\nvec3 hitPoint(float hitAngle, float yc, vec3 point, mat3 rrotation) {\n    float hitPoint = hitAngle / (2.0 * PI);\n    point.y = hitPoint;\n    return rrotation * point;\n}\n\nvec4 antiAlias(vec4 color1, vec4 color2, float distance) {\n    distance *= scale;\n    if (distance < 0.0) return color2;\n    if (distance > 2.0) return color1;\n    float dd = pow(1.0 - distance / 2.0, sharpness);\n    return ((color2 - color1) * dd) + color1;\n}\n\nfloat distanceToEdge(vec3 point) {\n    float dx = abs(point.x > 0.5 ? 1.0 - point.x : point.x);\n    float dy = abs(point.y > 0.5 ? 1.0 - point.y : point.y);\n    if (point.x < 0.0) dx = -point.x;\n    if (point.x > 1.0) dx = point.x - 1.0;\n    if (point.y < 0.0) dy = -point.y;\n    if (point.y > 1.0) dy = point.y - 1.0;\n    if ((point.x < 0.0 || point.x > 1.0) && (point.y < 0.0 || point.y > 1.0)) return sqrt(dx * dx + dy * dy);\n    return min(dx, dy);\n}\n\nvec4 seeThrough(float cylinderAngle, float yc, vec2 p, mat3 rotation, mat3 rrotation) {\n    float hitAngle = PI - (acos(yc / cylinderRadius) - cylinderAngle);\n    vec3 point = hitPoint(hitAngle, yc, rotation * vec3(p, 1.0), rrotation);\n\n    if (yc <= 0.0 && (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0)) {\n        return texture2D(targetTex, v_uv0);\n    }\n\n    if (yc > 0.0) return texture2D(texture, p);\n\n    vec4 color = texture2D(texture, point.xy);\n    vec4 tcolor = vec4(0.0);\n\n    return antiAlias(color, tcolor, distanceToEdge(point));\n}\n\nvec4 seeThroughWithShadow(float amount, float cylinderAngle, float yc, vec2 p, vec3 point, mat3 rotation, mat3 rrotation) {\n    float shadow = distanceToEdge(point) * 30.0;\n    shadow = (1.0 - shadow) / 3.0;\n    if (shadow < 0.0) shadow = 0.0;\n    else shadow *= amount;\n\n    vec4 shadowColor = seeThrough(cylinderAngle, yc, p, rotation, rrotation);\n    shadowColor.r -= shadow;\n    shadowColor.g -= shadow;\n    shadowColor.b -= shadow;\n    return shadowColor;\n}\n\nvec4 backside(float yc, vec3 point) {\n    vec4 color = texture2D(texture, point.xy);\n    float gray = (color.r + color.b + color.g) / 15.0;\n    gray += (8.0 / 10.0) * (pow(1.0 - abs(yc / cylinderRadius), 2.0 / 10.0) / 2.0 + (5.0 / 10.0));\n    color.rgb = vec3(gray);\n    return color;\n}\n\nvec4 behindSurface(float amount, float cylinderAngle, float yc, vec3 point, mat3 rrotation) {\n    float shado = (1.0 - ((-cylinderRadius - yc) / amount * 7.0)) / 6.0;\n    shado *= 1.0 - abs(point.x - 0.5);\n\n    yc = (-cylinderRadius - cylinderRadius - yc);\n\n    float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\n    point = hitPoint(hitAngle, yc, point, rrotation);\n\n    if (yc < 0.0 && point.x >= 0.0 && point.y >= 0.0 && point.x <= 1.0 && point.y <= 1.0 && (hitAngle < PI || amount > 0.5)){\n        shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / (71.0 / 100.0));\n        shado *= pow(-yc / cylinderRadius, 3.0);\n        shado *= 0.5;\n    } else\n        shado = 0.0;\n\n    return vec4(texture2D(targetTex, v_uv0).rgb - shado, 0.0);\n}\n\nvoid main(void) {\n    const float angle = 30.0 * PI / 180.0;\n    float c = cos(-angle);\n    float s = sin(-angle);\n\n    mat3 rotation = mat3(\n        c, s, 0,\n        -s, c, 0,\n        0.12, 0.258, 1\n    );\n\n    c = cos(angle);\n    s = sin(angle);\n\n    mat3 rrotation = mat3(\n        c, s, 0,\n        -s, c, 0,\n        0.15, -0.5, 1\n    );\n\n    vec3 point = rotation * vec3(v_uv0, 1.0);\n\n    float amount = time * (MAX_AMOUNT - MIN_AMOUNT) + MIN_AMOUNT;\n    float cylinderAngle = 2.0 * PI * amount;\n\n    float yc = point.y - amount;\n\n    if (yc < -cylinderRadius) {\n\n        gl_FragColor = behindSurface(amount, cylinderAngle, yc, point, rrotation);\n        return;\n    }\n\n    if (yc > cylinderRadius) {\n\n        gl_FragColor = texture2D(texture, v_uv0);\n        return;\n    }\n\n    float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\n\n    float hitAngleMod = mod(hitAngle, 2.0 * PI);\n    if ((hitAngleMod > PI && amount < 0.5) || (hitAngleMod > PI/2.0 && amount < 0.0)) {\n        gl_FragColor = seeThrough(cylinderAngle, yc, v_uv0, rotation, rrotation);\n        return;\n    }\n\n    point = hitPoint(hitAngle, yc, point, rrotation);\n\n    if (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0) {\n        gl_FragColor = seeThroughWithShadow(amount, cylinderAngle, yc, v_uv0, point, rotation, rrotation);\n        return;\n    }\n\n    vec4 color = backside(yc, point);\n\n    vec4 otherColor;\n    if (yc < 0.0) {\n        float shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / 0.71);\n        shado *= pow(-yc / cylinderRadius, 3.0);\n        shado *= 0.5;\n        otherColor = vec4(0.0, 0.0, 0.0, shado);\n    } else {\n        otherColor = texture2D(texture, v_uv0);\n    }\n\n    color = antiAlias(color, otherColor, cylinderRadius - abs(yc));\n\n    vec4 cl = seeThroughWithShadow(amount, cylinderAngle, yc, v_uv0, point, rotation, rrotation);\n    float dist = distanceToEdge(point);\n\n    gl_FragColor = antiAlias(color, cl, dist);\n}\n"
      }
    }
  ],
  "subMetas": {}
}